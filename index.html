<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>plist → PSD (preserved layer) — GitHub Pages-ready</title>

  <!-- Minimal styling (feel free to drop into gh-pages) -->
  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --muted:#94a3b8; --accent:#7c3aed;
      color-scheme: dark;
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,var(--bg),#071229);font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; color:#e6eef8; padding:28px;}
    .wrap{max-width:980px;margin:0 auto;display:grid;grid-template-columns:1fr 420px;gap:18px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03); padding:16px; border-radius:12px; box-shadow:0 6px 24px rgba(2,6,23,0.6)}
    h1{font-size:18px;margin:4px 0 12px}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    textarea{width:100%;height:420px;padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:#031025;color:#dff1ff; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; font-size:13px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    button{background:linear-gradient(90deg,var(--accent),#5b21b6);border:0;padding:10px 12px;border-radius:10px;color:white;font-weight:600;cursor:pointer}
    .mutebtn{background:transparent;border:1px solid rgba(255,255,255,0.04); color:var(--muted); padding:8px 10px;border-radius:8px}
    .right{display:flex;flex-direction:column;gap:12px}
    .meta{font-size:13px;color:var(--muted);padding:12px;border-radius:8px;background:rgba(255,255,255,0.01)}
    input[type=file]{display:block}
    .small{font-size:12px;color:var(--muted)}
    .log{height:160px;overflow:auto;padding:10px;border-radius:8px;background:#041423;border:1px solid rgba(255,255,255,0.02);font-family:ui-monospace,monospace;font-size:12px; color:#cfeefe}
    footer{grid-column:1/-1;margin-top:8px;text-align:center;color:var(--muted);font-size:12px}
    @media (max-width:980px){.wrap{grid-template-columns:1fr;}.right{order:2}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>plist → PSD (preserve plist in a PSD layer)</h1>

      <label for="plist">Paste plist XML (or drop a .plist file)</label>
      <textarea id="plist" spellcheck="false" placeholder="Paste your plist XML here..."></textarea>

      <div style="display:flex;gap:10px;margin-top:10px;align-items:center">
        <label class="small">Optional: upload sprite sheet (PNG)</label>
        <input id="sheet" type="file" accept="image/png,image/*" style="margin-left:auto" />
      </div>

      <div class="controls">
        <button id="gen">Generate PSD</button>
        <button id="download-raw" class="mutebtn">Download plist (.plist)</button>
        <button id="preview" class="mutebtn">Preview parsed frames</button>
        <div style="margin-left:auto" class="small">Result: single PSD with preserved plist in its top text layer + one text layer per frame</div>
      </div>

      <div style="margin-top:12px">
        <label class="small">Log / status</label>
        <div id="log" class="log">Ready.</div>
      </div>
    </div>

    <div class="right">
      <div class="card meta">
        <strong>How this works</strong>
        <p class="small" style="margin:8px 0 0">
          The page parses the plist XML, creates a PSD binary in the browser, then downloads it. The original plist is embedded as a top text layer (preserved), and every frame entry becomes its own text layer with the frame metadata.
        </p>
      </div>

      <div class="card">
        <label class="small">Parsed frames (click Preview)</label>
        <div id="frames" style="max-height:320px;overflow:auto;padding:10px;border-radius:8px;background:#041423;border:1px solid rgba(255,255,255,0.02);font-family:ui-monospace,monospace;font-size:12px;color:#cfeefe"></div>
      </div>

      <div class="card small">
        Notes:
        <ul>
          <li>The generator creates text layers only (no image layers). Use the sprite sheet upload to keep filename references — embedding raster images into PSD layers is possible but requires extra steps; ask if you want that and I can add it.</li>
          <li>Files produced are directly downloadable and suitable for committing to a GitHub repo and serving via GitHub Pages.</li>
        </ul>
      </div>
    </div>

    <footer class="small">Drop your plist into the textarea, then press Generate PSD</footer>
  </div>

  <!-- runtime libs (browser ESM) -->
  <script type="module">
    // ag-psd (browser ESM). If you want a specific version, replace the path with a versioned URL.
    import * as agpsd from 'https://unpkg.com/ag-psd@6.4.1/dist/ag-psd.esm.js';

    const plistEl = document.getElementById('plist');
    const sheetIn = document.getElementById('sheet');
    const genBtn = document.getElementById('gen');
    const dlRaw = document.getElementById('download-raw');
    const previewBtn = document.getElementById('preview');
    const framesBox = document.getElementById('frames');
    const log = document.getElementById('log');

    function logMsg(...args){ log.textContent = args.join(' ') + '\\n' + log.textContent; }

    // parse plist XML into a JS object (limited to the kinds of structure in your sample)
    function parsePlistXml(xmlText){
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlText.trim(), 'application/xml');
      if (doc.querySelector('parsererror')) throw new Error('Invalid XML / plist');
      // recursive helper
      function nodeToValue(node){
        const tag = node.tagName;
        if (tag === 'dict'){
          const out = {};
          const children = Array.from(node.children);
          for (let i=0;i<children.length; i+=2){
            const key = children[i]; const val = children[i+1];
            if (!key || !val) continue;
            out[key.textContent] = nodeToValue(val);
          }
          return out;
        }
        if (tag === 'array'){
          return Array.from(node.children).map(n => nodeToValue(n));
        }
        if (tag === 'true') return true;
        if (tag === 'false') return false;
        if (tag === 'integer') return parseInt(node.textContent,10);
        if (tag === 'string') return node.textContent;
        // fallback: try named child
        return node.textContent || null;
      }
      const plist = doc.querySelector('plist > dict');
      if (!plist) throw new Error('No top-level dict found');
      return nodeToValue(plist);
    }

    // Build a PSD using ag-psd. We'll make a root psd with:
// - a top text layer containing the raw plist (preserved layer)
// - one text layer per frame with its name + key properties
// Layer order: frames at the bottom, plist text on top
    function buildPsdFromPlist(plistText, parsed){
      const framesDict = parsed.frames || {};
      const frameKeys = Object.keys(framesDict);

      // canvas size — use metadata.size if present
      let canvasSize = {width: 1024, height: 1024};
      if (parsed.metadata && parsed.metadata.size){
        const m = parsed.metadata.size.replace(/[{}]/g,'').split(',');
        const w = parseInt(m[0],10), h = parseInt(m[1],10);
        if (!isNaN(w) && !isNaN(h)) canvasSize = {width:w, height:h};
      }

      // layers array: each layer is a simple text layer using ag-psd text engine format
      const layers = [];

      // reverse order so first frame is bottom layer
      for (const name of frameKeys.reverse()){
        const f = framesDict[name];
        const text = [
          name,
          'spriteSize: ' + (f.spriteSize || ''),
          'spriteOffset: ' + (f.spriteOffset || ''),
          'textureRect: ' + (f.textureRect || ''),
          'textureRotated: ' + (f.textureRotated === true ? 'true' : 'false')
        ].join('\\n');

        // simple text layer object suitable for ag-psd
        layers.push({
          name,
          text: {
            // ag-psd supports a text property with raw text content; the structure below is minimal
            value: text,
            engineData: {
              // minimal engine data so Photoshop recognizes a text layer
              "ResourceDict": {},
              "Styles": {},
              "Version": 1
            }
          },
          top: 0, left: 0, right: canvasSize.width, bottom: canvasSize.height,
          // mark as visible
          visible: true
        });
      }

      // top preserved layer containing the full plist (raw)
      layers.push({
        name: 'original-plist.plist (preserved)',
        text: {
          value: plistText,
          engineData: {
            "ResourceDict": {},
            "Styles": {},
            "Version": 1
          }
        },
        top: 0, left: 0, right: canvasSize.width, bottom: canvasSize.height,
        visible: true
      });

      // Compose PSD root object for ag-psd
      const psd = {
        width: canvasSize.width,
        height: canvasSize.height,
        resources: {},
        children: layers.map(l => {
          // ag-psd expects children with type 'layer' and possibly a text property
          const layer = {
            type: 'layer',
            name: l.name,
            left: l.left,
            top: l.top,
            right: l.right,
            bottom: l.bottom,
            visible: l.visible,
            opacity: 255,
            text: l.text // ag-psd will write a text layer block when text is present
          };
          return layer;
        })
      };

      return psd;
    }

    function downloadBlob(filename, blob){
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    genBtn.addEventListener('click', async ()=>{
      const txt = plistEl.value.trim();
      if (!txt) { logMsg('No plist text found'); return; }
      logMsg('Parsing plist...');
      let parsed;
      try{
        parsed = parsePlistXml(txt);
      }catch(e){
        logMsg('Error parsing plist:', e.message);
        return;
      }
      logMsg('Building PSD structure...');
      const psdJson = buildPsdFromPlist(txt, parsed);
      logMsg('Serializing PSD binary (this may take a few seconds)...');

      try{
        // writePsd returns an ArrayBuffer
        const arr = agpsd.writePsd(psdJson, {quality: 8});
        const blob = new Blob([arr], {type: 'application/octet-stream'});
        downloadBlob('plist_preserved.psd', blob);
        logMsg('Downloaded plist_preserved.psd');
      }catch(err){
        logMsg('ag-psd error: ', err && err.message ? err.message : String(err));
      }
    });

    dlRaw.addEventListener('click', ()=>{
      const txt = plistEl.value.trim();
      if (!txt) { logMsg('No plist to download'); return; }
      const blob = new Blob([txt], {type:'application/xml'});
      downloadBlob('sheet.plist', blob);
      logMsg('Downloaded sheet.plist');
    });

    previewBtn.addEventListener('click', ()=>{
      const txt = plistEl.value.trim();
      if (!txt) { framesBox.textContent = 'No plist'; return; }
      let parsed;
      try{ parsed = parsePlistXml(txt); } catch(e){ framesBox.textContent = 'Parse error: ' + e.message; return; }
      const frames = parsed.frames || {};
      const keys = Object.keys(frames);
      if (!keys.length){ framesBox.textContent = 'No frames found'; return; }
      framesBox.innerHTML = '';
      for (const k of keys){
        const f = frames[k];
        const div = document.createElement('div');
        div.style.padding = '8px 6px';
        div.style.borderBottom = '1px solid rgba(255,255,255,0.02)';
        div.innerHTML = `<strong>${k}</strong><div class="small" style="color:var(--muted);margin-top:6px">
          spriteSize: ${f.spriteSize || ''} — spriteOffset: ${f.spriteOffset || ''} — textureRect: ${f.textureRect || ''}</div>`;
        framesBox.appendChild(div);
      }
      logMsg('Preview rendered: ' + keys.length + ' frames');
    });

    // support dropping a .plist file into the textarea
    plistEl.addEventListener('dragover', e => e.preventDefault());
    plistEl.addEventListener('drop', e=>{
      e.preventDefault();
      const f = e.dataTransfer.files && e.dataTransfer.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = () => { plistEl.value = reader.result; logMsg('Loaded plist from file: ' + f.name); };
      reader.readAsText(f);
    });

    // basic auto-fill example: if user pastes the sample (from your message) this will already work
    // done
  </script>
</body>
</html>
